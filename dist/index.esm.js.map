{"version":3,"file":"index.esm.js","sources":["../src/types.ts","../src/utils.ts","../src/promise.ts","../src/client.ts","../src/handler.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const BaseRequest = z.object({\n    name: z.string(),\n    args: z.any().array(),\n});\n\nexport const SingleRequest = BaseRequest.extend({\n    type: z.literal(\"single\"),\n});\n\nexport const GroupRequest = z.object({\n    type: z.literal(\"group\"),\n    content: BaseRequest.array(),\n});\n\n// let x : PromiseSettledResult\n\nexport const BaseResponseFullfilled = z.object({\n    status: z.literal(\"fulfilled\"),\n    value: z.any(),\n});\n\nexport const BaseResponseRejected = z.object({\n    status: z.literal(\"rejected\"),\n    reason: z.any(),\n});\n\nexport const BaseResponse = BaseResponseFullfilled.or(BaseResponseRejected);\nexport const SingleResponse = BaseResponse;\nexport const GroupResponse = BaseResponse.array();\n\nexport const MixinResponse = SingleResponse.or(GroupResponse);\nexport const MixinRequest = SingleRequest.or(GroupRequest);\n\n\n\nexport const MixinError = z.object({\n    name: z.string(),\n    message: z.string(),\n    cause: z.any().optional(),\n    stack: z.string().optional(),\n})","import { MixinError } from \"./types\"\nimport { z } from \"zod\";\n\nexport function ErrorToJson(error: any){\n    if(error instanceof Error){\n        const result: z.infer<typeof MixinError> =  {\n            message: error.message,\n            name: error.name,\n            cause: error.cause,\n            stack: error.stack\n        }\n        return result\n    }else{\n        console.log(error);\n        \n        return {\n           ...error\n        }\n    }\n    \n}\n\nexport function JsonToError(input: any){\n    const output = MixinError.safeParse(input)\n    if(output.success){\n        const error = output.data\n        return new class extends Error{\n            name = error.name\n            message = error.message\n            cause = error.cause\n            stack = error.stack\n        }\n    }else{\n        return new Error(input)\n    }\n}","import { z } from \"zod\";\nimport { SingleRequest, SingleResponse } from \"./types\";\nimport { JsonToError } from \"./utils\";\nimport fetch from 'cross-fetch'\nexport default class MixinPromise {\n    constructor(\n        private url: string,\n        private fnName: string,\n        private fnArgs: any[]\n    ) {}\n\n    async single() {\n        try {\n            const request: z.infer<typeof SingleRequest> = {\n                type: \"single\",\n                name: this.fnName,\n                args: this.fnArgs,\n            };\n            return fetch(this.url, {\n                method: \"POST\",\n                body: JSON.stringify(request),\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            })\n                .then((d) => d.json())\n                .then((d) => SingleResponse.safeParse(d))\n                .then((d) => {\n                    if (d.success) return d.data;\n                    else throw new Error(\"bad Response\");\n                })\n                .then((d) => {\n                    if (d.status === \"fulfilled\") return d.value;\n                    else throw JsonToError(d.reason);\n                });\n        } catch (reason) {\n            throw new Error(\"bad Response\");\n        }\n    }\n    //@ts-ignore\n    then<T, R>(\n        onresolve: (data: T) => R,\n        onreject?: (reason: any) => MixinPromise\n    ) {\n        return this.single().then(onresolve, onreject);\n    }\n}\n","import { BaseSymbol } from \"./handler\";\nimport { z } from \"zod\";\nimport MixinPromise from \"./promise\";\n\ntype ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any\n    ? R\n    : never;\n\n\ntype Promisify<T> = T extends Promise<any> ? T : Promise<T>;\n\ntype ToAsyncFn<Fn extends (...args: any) => any> =\n    Parameters<Fn>[0][typeof BaseSymbol] extends true | undefined //TODO: i doubt this is a good practice\n        ? (...args: ParametersExceptFirst<Fn>) => Promisify<ReturnType<Fn>>\n        : (...args: Parameters<Fn>) => Promisify<ReturnType<Fn>>;\n\n\ntype Elms<T extends z.ZodType> = z.infer<T>\n\nexport default function compile<Shape extends z.ZodRawShape>(\n    schema: z.ZodObject<Shape>,\n    url: string\n) {\n    //@ts-ignore: TS2589\n    // type Elms = z.infer<typeof schema>;\n\n    const proxy = new Proxy(\n        {},\n        {\n            get(_self, name, _r) {\n                if (name === \"$\") throw new Error(\"not implemented\");\n                return async (...args: any[]) => {\n                    return await new MixinPromise(url, name.toString(), args);\n                };\n            },\n        }\n    );\n\n    return proxy as { [k in keyof Elms<typeof schema>]: ToAsyncFn<Elms<typeof schema>[k]> };\n}\n","import { z } from \"zod\";\nimport {\n    GroupRequest,\n    MixinRequest,\n    SingleRequest,\n    SingleResponse,\n} from \"./types\";\nimport { ErrorToJson } from \"./utils\";\n\nexport const BaseSymbol = Symbol(\"Base\");\n\nexport const BaseContext = z.object({\n    [BaseSymbol]: z.literal(true).default(true),\n});\n\nconst BaseShape = BaseContext.shape;\n\nexport default class Handler<\n    Shape extends z.ZodRawShape,\n    ContextShape extends typeof BaseShape\n> {\n    private functions: z.infer<z.ZodObject<Shape>>;\n    private shape: Shape;\n    constructor(\n        schema: z.ZodObject<Shape>,\n        implementation: z.infer<z.ZodObject<Shape>>,\n        private context: z.ZodObject<ContextShape>\n    ) {\n        const output = schema.safeParse(implementation);\n        if (output.success) {\n            this.functions = output.data;\n            this.shape = schema.shape;\n        } else {\n            throw new Error(\"Functions are not compatable\");\n        }\n    }\n\n    private async call(\n        name: string,\n        args: any[],\n        context: z.infer<z.ZodObject<ContextShape>>\n    ) {\n        if (Object.hasOwn(this.functions, name)) {\n            //@ts-ignore\n            const fnImpl = this.functions[name];\n            const fnSign = this.shape[name] as z.ZodFunction<any, any>;\n            const firstParamIsContext =\n                !!fnSign.parameters().items?.[0]?.shape?.[BaseSymbol];\n\n            if (firstParamIsContext) args = [context, ...args];\n\n            try {\n                const value = await fnImpl(...args);\n                const response: z.infer<typeof SingleResponse> = {\n                    status: \"fulfilled\",\n                    value,\n                };\n                return response;\n            } catch (reason) {\n                const response: z.infer<typeof SingleResponse> = {\n                    status: \"rejected\",\n                    reason: ErrorToJson(reason),\n                };\n                return response;\n            }\n        } else {\n            const response: z.infer<typeof SingleResponse> = {\n                status: \"rejected\",\n                reason: ErrorToJson(new Error(\"Function Not Found\")),\n            };\n            return response;\n        }\n    }\n\n    private async single(\n        request: Omit<z.infer<typeof SingleRequest>, \"type\">,\n        context: z.infer<z.ZodObject<ContextShape>>\n    ) {\n        const { args, name } = request;\n        if (Object.hasOwn(this.functions, name)) {\n            return this.call(name, args, context);\n        } else {\n            throw new Error(\"Not found\");\n        }\n    }\n\n    private async group(\n        request: z.infer<typeof GroupRequest>,\n        context: z.infer<z.ZodObject<ContextShape>>\n    ) {\n        const { content } = request;\n        return await Promise.allSettled(\n            content.map(async (fn) => {\n                return this.single(fn, context);\n            })\n        );\n    }\n\n    async handle(\n        rewRequest: unknown,\n        rawContext: Omit<z.infer<z.ZodObject<ContextShape>>, typeof BaseSymbol>\n    ) {\n        const contextInput = this.context.safeParse(rawContext);\n        if (!contextInput.success) throw new Error(\"Bad Context\");\n        const context = contextInput.data;\n\n        const requestInput = MixinRequest.safeParse(rewRequest);\n        if (!requestInput.success)\n            throw new Error(\"Bad Request form\", {\n                //@ts-ignore\n                cause: requestInput.error.message,\n            });\n\n        const request = requestInput.data;\n        if (request.type === \"single\") {\n            return await this.single(request, context);\n        } else {\n            return await this.group(request, context);\n        }\n    }\n}\n\n\n\n\n"],"names":["BaseRequest","z","object","name","string","args","any","array","SingleRequest","extend","type","literal","GroupRequest","content","BaseResponseFullfilled","status","value","BaseResponseRejected","reason","BaseResponse","or","SingleResponse","GroupResponse","MixinResponse","MixinRequest","MixinError","message","cause","optional","stack","ErrorToJson","error","Error","console","log","_extends","JsonToError","input","output","safeParse","success","data","_Error","_class2","_len","_this","arguments","length","Array","_key","call","apply","concat","_wrapNativeSuper","MixinPromise","url","fnName","fnArgs","this","_proto","prototype","single","Promise","resolve","fetch","method","body","JSON","stringify","headers","then","d","json","e","reject","onresolve","onreject","compile","schema","proxy","Proxy","get","_self","_r","_arguments","toString","slice","BaseSymbol","Symbol","_z$object","Handler","implementation","context","functions","shape","Object","hasOwn","_fnSign$parameters$it","_fnSign$parameters$it2","_fnSign$parameters$it3","fnImpl","parameters","items","_catch","response","request","group","_this3","allSettled","map","fn","handle","rewRequest","rawContext","_this4","contextInput","requestInput"],"mappings":"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"}