{"version":3,"file":"client.umd.js","sources":["../src/types.ts","../src/promise.ts","../src/utils.ts","../src/client.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const BaseRequest = z.object({\n    name: z.string(),\n    args: z.any().array(),\n});\n\nexport const SingleRequest = BaseRequest.extend({\n    type: z.literal(\"single\"),\n});\n\nexport const GroupRequest = z.object({\n    type: z.literal(\"group\"),\n    content: BaseRequest.array(),\n});\n\n// let x : PromiseSettledResult\n\nexport const BaseResponseFullfilled = z.object({\n    status: z.literal(\"fulfilled\"),\n    value: z.any(),\n});\n\nexport const BaseResponseRejected = z.object({\n    status: z.literal(\"rejected\"),\n    reason: z.any(),\n});\n\nexport const BaseResponse = BaseResponseFullfilled.or(BaseResponseRejected);\nexport const SingleResponse = BaseResponse;\nexport const GroupResponse = BaseResponse.array();\n\nexport const MixinResponse = SingleResponse.or(GroupResponse);\nexport const MixinRequest = SingleRequest.or(GroupRequest);\n\n\n\nexport const MixinError = z.object({\n    name: z.string(),\n    message: z.string(),\n    cause: z.any().optional(),\n    stack: z.string().optional(),\n})","import { z } from \"zod\";\nimport { SingleRequest, SingleResponse } from \"./types\";\nimport { JsonToError } from \"./utils\";\nimport fetch from 'cross-fetch'\nexport default class MixinPromise {\n    constructor(\n        private url: string,\n        private fnName: string,\n        private fnArgs: any[]\n    ) {}\n\n    async single() {\n        try {\n            const request: z.infer<typeof SingleRequest> = {\n                type: \"single\",\n                name: this.fnName,\n                args: this.fnArgs,\n            };\n            return fetch(this.url, {\n                method: \"POST\",\n                body: JSON.stringify(request),\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            })\n                .then((d) => d.json())\n                .then((d) => SingleResponse.safeParse(d))\n                .then((d) => {\n                    if (d.success) return d.data;\n                    else throw new Error(\"bad Response\");\n                })\n                .then((d) => {\n                    if (d.status === \"fulfilled\") return d.value;\n                    else throw JsonToError(d.reason);\n                });\n        } catch (reason) {\n            throw new Error(\"bad Response\");\n        }\n    }\n    //@ts-ignore\n    then<T, R>(\n        onresolve: (data: T) => R,\n        onreject?: (reason: any) => MixinPromise\n    ) {\n        return this.single().then(onresolve, onreject);\n    }\n}\n","import { MixinError } from \"./types\"\nimport { z } from \"zod\";\n\nexport function ErrorToJson(error: any){\n    if(error instanceof Error){\n        const result: z.infer<typeof MixinError> =  {\n            message: error.message,\n            name: error.name,\n            cause: error.cause,\n            stack: error.stack\n        }\n        return result\n    }else{\n        console.log(error);\n        \n        return {\n           ...error\n        }\n    }\n    \n}\n\nexport function JsonToError(input: any){\n    const output = MixinError.safeParse(input)\n    if(output.success){\n        const error = output.data\n        return new class extends Error{\n            name = error.name\n            message = error.message\n            cause = error.cause\n            stack = error.stack\n        }\n    }else{\n        return new Error(input)\n    }\n}","import { BaseSymbol } from \"./handler\";\nimport { z } from \"zod\";\nimport MixinPromise from \"./promise\";\n\ntype ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any\n    ? R\n    : never;\n\n\ntype Promisify<T> = T extends Promise<any> ? T : Promise<T>;\n\ntype ToAsyncFn<Fn extends (...args: any) => any> =\n    Parameters<Fn>[0][typeof BaseSymbol] extends true | undefined //TODO: i doubt this is a good practice\n        ? (...args: ParametersExceptFirst<Fn>) => Promisify<ReturnType<Fn>>\n        : (...args: Parameters<Fn>) => Promisify<ReturnType<Fn>>;\n\n\ntype Elms<T extends z.ZodType> = z.infer<T>\n\nexport default function compile<Shape extends z.ZodRawShape>(\n    schema: z.ZodObject<Shape>,\n    url: string\n) {\n    //@ts-ignore: TS2589\n    // type Elms = z.infer<typeof schema>;\n\n    const proxy = new Proxy(\n        {},\n        {\n            get(_self, name, _r) {\n                if (name === \"$\") throw new Error(\"not implemented\");\n                return async (...args: any[]) => {\n                    return await new MixinPromise(url, name.toString(), args);\n                };\n            },\n        }\n    );\n\n    return proxy as { [k in keyof Elms<typeof schema>]: ToAsyncFn<Elms<typeof schema>[k]> };\n}\n"],"names":["BaseRequest","z","object","name","string","args","any","array","SingleRequest","extend","type","literal","GroupRequest","content","BaseResponseFullfilled","status","value","BaseResponseRejected","reason","BaseResponse","or","SingleResponse","GroupResponse","MixinError","message","cause","optional","stack","MixinPromise","url","fnName","fnArgs","this","_proto","prototype","single","_this","Promise","resolve","fetch","method","body","JSON","stringify","headers","then","d","json","safeParse","success","data","Error","input","output","error","_Error","_class2","_len","arguments","length","Array","_key","call","apply","concat","_wrapNativeSuper","JsonToError","e","reject","onresolve","onreject","schema","proxy","Proxy","get","_self","_r","_arguments","toString","slice"],"mappings":"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"}